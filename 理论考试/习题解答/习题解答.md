# 第二章

## 8

在道数不受限制的多道程序系统中，作业进入系统的后备队列时立即进行作业调度。现有4个作业进人系统，有关信息为

| 作业名 | 进入后备队列的时刻 | 执行时间/min | 优先数 |
| ------ | ------------------ | ------------ | ------ |
| Job1   | 8:00               | 60           | 1      |
| Job2   | 8:30               | 50           | 2      |
| Job3   | 8:40               | 30           | 4      |
| Job4   | 8:50               | 10           | 3      |

作业调度和进程调度均采用高优先算法（规定数值越大则优先越高）。试填充下表。

| 作业名 | 进入后备队列的时刻 | 执行时间/min | 开始执行时刻 | 结束执行时刻 | 周转时间/min | [带权周转时间](https://baike.baidu.com/item/%E5%B8%A6%E6%9D%83%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4/7145942?fr=aladdin)/min |
| ------ | ------------------ | ------------ | ------------ | ------------ | ------------ | ------------------------------------------------------------ |
|        |                    |              |              |              |              |                                                              |
|        |                    |              |              |              |              |                                                              |
|        |                    |              |              |              |              |                                                              |
|        |                    |              |              |              |              |                                                              |

| 平均周转时间T=     |
| ------------------ |
| 平均带权周转时间W= |

----------------------------------------------------------------

非抢占式,在同一时刻的作业，按优先数来，只要在执行就不能抢占

| 作业名 | 进入后备队列的时刻 | 执行时间/min | 开始执行时刻 | 结束执行时刻 | 周转时间/min | 带权周转时间/min |
| ------ | ------------------ | ------------ | ------------ | ------------ | ------------ | ---------------- |
| Job1   | 8:00               | 60           | 8:00         | 9:00         | 60           | 1                |
| Job2   | 8:30               | 50           | 9:40         | 10:30        | 120          | 2.4              |
| Job3   | 8:40               | 30           | 9:00         | 9:30         | 50           | 1.67             |
| Job4   | 8:50               | 10           | 9:30         | 9:40         | 50           | 5                |

| 平均周转时间T=(60+120+50+50)/4=70       |
| --------------------------------------- |
| 平均带权周转时间W=(1+2.4+1.67+5)/4=2.52 |

抢占式，在同一时刻的多个作业，按优先数来，谁多谁就可以抢占

| 作业名 | 进入后备队列的时刻 | 执行时间/min | 开始执行时刻 | 结束执行时刻 | 周转时间/min | 带权周转时间/min |
| ------ | ------------------ | ------------ | ------------ | ------------ | ------------ | ---------------- |
| Job1   | 8:00               | 60           | 8:00         | 10:30        | 150          | 2.5              |
| Job2   | 8:30               | 50           | 8:30         | 10:00        | 90           | 1.8              |
| Job3   | 8:40               | 30           | 8:40         | 9:10         | 30           | 1                |
| Job4   | 8:50               | 10           | 9:10         | 9:20         | 30           | 3                |

| 平均周转时间T=(150+90+30+30)/4=75       |
| --------------------------------------- |
| 平均带权周转时间W=(2.5+1.8+1+3)/4=2.075 |

## 21

有一个具有三道作业的多道批处理系统，作业调度采用短作业优先调度算法，进程调度采用以优先数为基础的抢占式调度算法。在下表所示的作业序列中，作业优先数即为进程优先数，优先数越小则优先级越高。

| 作业名 | 到达时刻 | 估计运行时间/min | 优先数 |
| ------ | -------- | ---------------- | ------ |
| A      | 10:00    | 40               | 5      |
| B      | 10:20    | 30               | 3      |
| C      | 10:30    | 60               | 4      |
| D      | 10:50    | 20               | 6      |
| E      | 11:00    | 20               | 4      |
| F      | 11:10    | 10               | 4      |

试填充下表：

| 作业 | 进入内存时刻 | 运行结束时刻 | 作业周转时间/min |
| ---- | ------------ | ------------ | ---------------- |
| A    |              |              |                  |
| B    |              |              |                  |
| C    |              |              |                  |
| D    |              |              |                  |
| E    |              |              |                  |
| F    |              |              |                  |

平均作业周转时间：

----------------------------------------------------------------------------------------------


| 作业 | 进入内存时刻 | 运行结束时刻 | 作业周转时间/min |
| ---- | ------------ | ------------ | ---------------- |
| A    | 10:00        | 12:40        | 160              |
| B    | 10:20        | 10:50        | 30               |
| C    | 10:30        | 11:50        | 80               |
| D    | 10:50        | 13:00        | 130              |
| E    | 12:00        | 12:20        | 80               |
| F    | 11:50        | 12:00        | 50               |

平均周转时间=(160+30+80+130+80+50)/6=88.88

## 23

有5个作业依次进入系统，其提交时刻、运行时间、作业长度分别为

| 作业 | 提交时刻 | 运行时间 | 作业长度/KB | 开始执行时刻 | 完成时刻 | 作业周转时间/min |
| ---- | -------- | -------- | ----------- | ------------ | -------- | ---------------- |
| Job1 | 10:00    | 25       | 15          |              |          |                  |
| Job2 | 10:20    | 30       | 60          |              |          |                  |
| Job3 | 10:20    | 25       | 40          |              |          |                  |
| Job4 | 10:30    | 15       | 20          |              |          |                  |
| Job5 | 10:35    | 10       | 30          |              |          |                  |

设内存容量为100KB，采用可变分区存储管理，且作业在内存中不能移动。作业调度采用先来先服务算法，作业所对应的进程调度采用内存中的就绪进程平分CPU时间的方式，不计作业对换及其他系统开销。试求各作业（进程）的开始执行时刻、完成时刻及周转时间。



## 27

某多道程序系统供用户使用的内存空间为100kb，磁带机2台，打印机1台。采用可变分区内存管理，采用静态方式分配外部设备，忽略用户业I/O操作时间。现有作业序列如下：

| 作业号 | 进入输入井时刻 | 运行时间/min | 内存需求量/KB | 磁带需求量/台 | 打印机需求量/台 |
| ------ | -------------- | ------------ | ------------- | ------------- | --------------- |
| 1      | 8:00           | 25           | 15            | 1             | 1               |
| 2      | 8:20           | 10           | 20            | 0             | 1               |
| 3      | 8:20           | 20           | 60            | 1             | 0               |
| 4      | 8:30           | 20           | 20            | 1             | 0               |
| 5      | 8:35           | 15           | 10            | 1             | 1               |

作业调度采用FCFS策略，优先分配内存低地址区且不准移动已在内存中的作业，内存中的各作业平分CPU时间。现求：（1）作业调度的先后次序；（2）全部作业运行结束的时刻；（3）作业平均周转时间；（4）最大作业周转时间。 

# 第三章

## 16

一个经典同步问题：吸烟者问题(patil , 1971 ）。三个吸烟者在一个房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴，供应者有丰富货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸和第三个有自己的火柴。供应者随机地将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再把两样东西放在桌子上，唤醒另一个吸烟者。试采用：( 1 ）信号量和P 、v 操作，( 2 ）管程编写他们同步工作的程序。答：( 1 ）用信号量和P 、v 操作。

```
 vars , S1 ,S2 , S3 ; semaphore ; 
 S:=1 ; S1:=S2:=S3:=0 ; 
 fiag1 , flag2 , fiag3 : Boolean ; 
 fiag1:=flag2:=flag3:=true;

cobegin 
 { 
  process 供应者
   begin 
    repeat 
    P(S) ; 
    取两样香烟原料放桌上，由flagi标记；  / * nago1 、nage2 、nage3 代表烟草、纸、火柴
    if flag2 & flag3 then V(S1) ;      / ＊供纸和火柴
    else if flag1 & fiag3 then V(S2 ) ;   / ＊供烟草和火柴
   else V(S3) ;              / ＊供烟草和纸
 untile false ; 
 end 
 process 吸烟者1 
 begin 
 repeat 
 P(S1) ; 
 取原料；
 做香烟；
 V(S) ; 
 吸香烟；

untile false ;

process 吸烟者2

 begin 
 repeat 

P (S2 ) ; 

取原料；

做香烟；

V(S) ;

吸香烟；

untile false ;

process 吸烟者3 

begin 
 repeat 

P (S3 ) ; 

取原料；

做香烟；

V ( S ) ; 

吸香烟；

untile false ; 

coend .

( 3 ）用管程。
 TYPE mskesmoke=moonitor 
 VAR S, S1 ,S2 ,S3 : condition ; 
 flag1 , flag2, flag3 : boolean 
 DEFINE give , take1 , take2 , take3 ; 
 USE check , wait , signal , release ; 
 procedure give 
 begin 
 check ( IM ) ; 
 准备香烟原料；
 if 桌上有香烟原料then wait( S , IM ) ; 把准备的香烟原料放桌上；
 if fiag2 & flag3 then signal ( S1 ,IM）;

if flag1 & flag3 then signal ( S2 ,IM ) ; else signal (S3 , IM ) ; 
 release ( IM ) ; 
 end 
 procedure take1 
 begin 
 check(IM):
 if 桌上没有香烟原料then wait ( S1 ,IM）; 

else 取原料；
 signal ( S , IM ) ; 

release ( IM ) ; 
 end 
 procedure take2
  begin 
  check ( IM ) : 
  if 桌上没有香烟原料 then wait(S2,IM);

else 取原料；
 signal ( S , IM ) ; 
 release （IM）; 
 end 

procedure take3 
 begin 
 check ( IM ) : 
 if 桌上没有香烟原料then wait(S3,IM);

else 取原料 

signal ( S ,IM ) ; 
 release ( IM ) ; 
 end 
 begin 
 flag1:=flag2:=flag3:=true;

end.


 cobegin 
 { 
 process 供应者
  begin 
 repeat 
 Call makesmoke.give(); 

……

until false ; 
 end 
 process 吸烟者1 
 begin
 repeat 
 Call makesmoke.take1() ;

做香烟，吸香烟；

until false ; 
 end 
 process 吸烟者2 
 begin 
 repeat 
 Call makesmoke.take2() ; 

做香烟，吸香烟；

until false ; 
 end 

process 吸烟者3 
 begin 
 repeat 
 Call makesmke.take3(); 

做香烟，吸香烟；

until false ; 
 end 
 } 
 coend . 
```



## 23

设当前的系统状态如下，此时Available=(1,1,2)。

|      | Claim                                                       | Allocation                                                   |
| ---- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 进程 | R1                          R2                         R3   | R1                          R2                         R3    |
| P1   | 3                             2                           2 | 1                            0                             0 |
| P2   | 6                             1                           3 | 5                            1                             1 |
| P3   | 3                             1                           4 | 2                            1                             1 |
| P4   | 4                             2                           2 | 0                            0                             2 |

（1）计算各个进程还需要的资源数Cki-Aki

（2）系统是否处于安全状态，为什么？

（3）进程P2发出请求向量 request2（1，0，1），系统能把资源分配给它吗？

（4）若在进程P2申请资源后，P1发出请求向量 request1（1，0，1），系统能把资源分配给它吗？

（5）若在进程P1申请资源后，P3发出请求向量 request3（0，0，1），系统能把资源分配给它吗？

```
l ）计算各个进程还需要的资源数Cki - Aki ? 
( 2 ）系统是否处于安全状态，为什么？
( 3 ) P2 发出请求向量request2 ( 1 , o , 1 ) ，系统能把资源分给它吗？
( 4 ）若在P2 申请资源后，若P1 发出请求向量req 够stl ( 1 ,0, l ) ，系统能把资源分给它吗？
( 5 ）若在P1 申请资源后，若P3 发出请求向量request3 ( 0 ,0，l ) ，系统能把资源分给它吗？
答：( 1 ) P1 , P2 , P3 , P4 的Cki . Aki 分别为：( 2 , 2 , 2 ）、（1 , 0 , 2 ）、（1 , 0 , 3 ）、（4 , 2 , 0 ) ( 4 ）系统处于安全状态，存在安全序：P2 , P1 , P3 , P4 
( 5 ）可以分配，存在安全序列：P2 , P1 , P3 , P4 . 
( 6 ）不可以分配，资源不足。
( 7 ）不可以分配，不安全状态。

```



## 26

考虑一个共有150个存储单元的系统，按如下方式分配给三个进程，P1最大需求70个，已占有25个；P2最大需求60个，已占有40个；P3最大需求60个，已占有45个。使用银行家算法以确定下面的任何一个请求是否安全：（1）进程P4到达，P4最大需求60个，最初请求25个。（2）进程P4到达，P4最大需求60个，最初请求35个。如果安全，请找出安全序列；如果不安全，请给出结果的分配情况。

( l ）由于系统目前还有150-25-40-45=40 个单元，P4 进程到达，把25 个单元分给它。这时系统还余15 个单元，可把15 个单元分给P3 ，它执行完后会释放60 个单元。于是可供P1 （还要45 个单元）, P2 （还要20 个单元）, P4(还要35 个单元)任何一个执行。

![image-20201222230003733](image/image-20201222230003733.png)

## 31

独木桥问题1：东西向汽车驶过独木桥，为了保证交通安全，只要桥上无车，则允许一方的汽车过桥，待其全部过完后才允许另一方的汽车过桥。请用信号量和PV操作写出汽车过独木桥问题的同步算法。

```
var wait ，mutex1 ，mutex2 , bridge1 , bridge2 : semaphore ; 
mutex1:＝mutex2:=bridgel:=bridge2:=1;wait:=0;
counter1 , counter2 : integer ; 
cobegin 
{ 
process P 左                          process P 右
  begin                                   begin 
P ( mutex1 ) ;                             P ( mutex2 ) ;
Count1 ++;                                  count2 ++；
if count1 = 1 then P( wait ) ;                if count2 = 1 then P( wait ) ;
V ( mutex1 ) ;                                 V( mutex2) ;
P(bridge1) ;                                   P ( bridge2 ) ; 
过独木桥；                                      过独木桥；
V ( bridge1) ;                                   V( bridge2 ) ;
P ( mutex1) ;                                    P ( mutex2 ) ;
 Count1-- ;                                       count2--；
if count1 = 0 then V(wait) ;                     if count2 = 0 then P (wait) ;
V ( mutex1) ;                                    V (mutex2) ; 
end  ;                                            end ;
} coend 

```



## 32

独木桥问题2：在独木桥问题1中，限制桥面上最多可以有k辆汽车通过。试用信号量和PV操作写出汽车过独木桥问题的同步算法。

## 37

某工厂有两个生产车间和一个装配车间，两个生产车间分别生产A、B两种零件，装配车间的任务是把A、B两种零件组装成产品。两个生产车间每生产一个零件后都要分别把它们送到装配车间的货架F1、F2上，F1存放零件A，F2放零件B，F1和F2的容量均为可以存放10个零件。装配工人每次从货架上取一个A零件和一个B零件，然后将其组装成产品。请用：（1）信号量和PV操作进行正确管理；（2）管程进行正确管理。

```
答：( 1 ）信号量和P 、V 操作进行正确管理．
var Fl , F2 : ARRAY [ 0…9 ] of item;
SP1 , SP2 , SI1 , SI2:seMaphore ; 
in1 , in2 ，outl ，outZ ：integer ; 
in1:=0;in2:=0;out1:=0；out2:=0；
SP1:=10;SP2:=10;SI1:=0;SI2:=0;
Main()
{cobegin
Producer1();
Producer2();
Installer()
Coend
}
Process producer1()
Begin
While(true)
{
Produce A零件；
P(SP1);
F1[in1]:A;
In1:=(in1+1) mod 10
V(SI1);
}
End
Process producer2()
Begin
 While(true)
{
Produce B零件；
P(SP2);
F2(in2):=B;
In2:=(in2+1) mod 10
V(SI2);
}
End
Process installer()
Var product:item;
Begin
While(true)
{ p(SI1);
Product1:=F1[out1];
Out1:=(out1+1) mod 10;
V(SP1);
P(SI2);
Product2:=F2[out2];
Out2:=(out2+1) mod 10;
V(SP2);
组装产品；
}
End
TYPE produceprodut=monitor 
VAR F1 , F2 : ARRAY [ 0 …9 ] of item;
SP1 , SP2 , SG1 , SG2:semaphore; 
SP1_count1,SP2 count2 , SG1_count,SG2_count:integer;
In1, in2 ，out1 ，out2:=integer ; 
inc1 , inc2 : integer ; 
DEFINE put1 , put2 , get : 
USE wait,signal; 
procedure put1( A ); 
begin 
if inc1=10 then wait ( SP1 , SP1_count , IM );
Inc1:=inc1 + 1 : 
F1[in1]:= A ; 
in1:=(in1 + 1 ) MOD 10 
signal ( SG1 , SG1_count , IM ) ; 
end : 
procedure put2 ( B ) : 
begin 
if inc2 =10 then wait ( SP2 , SP2_count , IM );
Inc2 :=inc2 + 1 ; 
F2 [in2]:=B; 
in2:=(in2 + 1 ) MOD 10 
signal ( SG2 , SG2_count , IM ) ; 
end ; 
procedure get ( A , B ) ; 
begin 
if inc1=0 then wait ( SG1 , SG1_count , IM ) ;
if inc2=0 then wait ( SG2 , SG2_count , IM ) ;
inc1:=inc1-1 ;
inc2:=inc2-1;
A:F1[out1]; 
out1:=(out1 + 1 ) MOD 10 
B:=F2[out2];
Out2 :=(out2 + 1 ) MOD 10 
signal ( SP1 , SP1_count , IM ) ; 
signal ( SP2 , SP2_count , IM ) ; 
end ; 
begin 
in1:=0 ;in2:=0;out1:=0;out2:=0;inc1:=0;inc2:=0 ; 
SP1:=0;SP2:=0;SG1:=0;SG2:=0;
end. 
cobegin 
{ 
process Produce1
begin
while(true)
{produce A零件；
P(IM.mutex);
Call produceprodut.put1(A);
If IM.next>0 then V(IM.next);
Else V(IM,mutex);
}
End;
Process Produce2
Begin
While(true)
{produce B零件;
P(IM.mutex);
Call produceprodut.put2(B);
If (IM.next>0 then V(IM.next);
Else V(IM,mutex);
}
Process consume
Begin
While(true)
{
P(IM.mutex);
Call produceprodut.get(A,B);
If IM.next>0 then V(IM.next);
Else V(IM,mutex);
组装产品；
}
End;
}
Coend.

```



## 38

桌上有一只盘子，最多可以容纳两个水果，每次仅能放入或取出一个水果。爸爸向盘子中放苹果（ apple），妈妈向盘子中放橘子（orange），两个儿子专等吃盘子里的橘子，两个女儿专等吃盘子里的苹果。试用（1）信号量和PV操作、（2）管程，来实现爸爸、妈妈、儿子、女儿间的同步与互斥关系。

```
答：( l ）用信号量和P 、v 操作．
类似于课文中的答案，扩充如下：1 ）同步信号量初值为2 ; 2 ）要引进一个互斥信号量mutex , 用于对盘子进行互斥：3 ）盘子中每一项用橘子、苹果2 个枚举值。
Var 
plate ARRAY [ 0 , 1] of ( apple , orange ) ; 
flag0 , fiag1:=boolean ; 
mutex : semaphore ; 
sp : semaphore;                              / ＊盘子里可以放几个水果＊/ 
sg1 , sg2 : semaphore ;                      / ＊盘子里有桔子，有苹果* /
sp : = 2 ;                                   / ＊盘子里允许放入二个水果＊/ 
sg1 :=sg2 :=0 ;                              / ＊盘子里没有桔子，没有苹果＊/ 
flag0:=flag1:=false ; mutex :=1 : 
cobegin                                  process son 
  process father                                begin 
  begin                                         L3 : P (sg1 ) ; 
L1 :削一个苹果；                              P( mutex ) ;
P ( sp ) ;                                    if（flag0&flte[0]==桔子） then 
If(flag0==false) then                         else{x:=plate[1];flag1:=false;}
{ plate[0]:＝苹果；flag1:=true;}              v(mutex);
else {plate[1]:=苹果；flag1:=true;}           V(sp) ; 
v (mutex );                                   吃桔子；
v(sg2)                                        goto L3;
goto Ll ;                                     end;
end ; 
process mother                                process daughter
begin                                            begin
L2 ：剥一个桔子；                                L4 : P ( 592 ) : 
P ( sp ) ;                                       P ( mutex )

P ( mutex ) ;                                    if ( flag0 & plate [0]=＝苹果）then
if ( flag0==false ）then                          {x:=plate [01]; flag0:=false ; }
{plate[0]:＝桔子；flag0:=true;)                    else { x:==plate[1] ; flag1:=false ; }
else {plate[1]:=＝桔子；flag1:＝true ; }             V ( mutex ) ;
V (mutex) ;                                          V ( sp ) ;
V (sg1) ;                                            吃苹果；
goto L2 ;                                             goto L4;
end ;                                                 end ;
                                                      coend . 
( 2 ）用管程．
TYPE FMSD = MONITOR 
VAR plate ARRAY [ 0 , 1 ] of ( apple , orange ) ;
Count:integer ; flag0，flag1:boolean ;
SP ,SS , SD : codition ; 
DEFFINE put,get ; 
USE wait,signal , check , release ; 
procedure put(var fruit:( apple ，orange ) ) ;
begin
check(IM ) ; 
if ( count=＝2 ) then wait(SP , IM ) ; 
else{if(flag0==false) then
{plate[0]:=fruit; flag0:=true;}
Else{plate[1]:=fruit;flag1:=true;}
Count:=count+1;
If(fruit==orange) then signal(ss,IM);
Else signal(SD,IM);
}
Release(IM);
End;
Procedure get(varfruit:(apple,orange),x:plate);
Begin
Check(IM);
If (count==0) or plate <>fruit
Then begin
If(fruit==orange) then wait(SS,IM);
Else wait(SD,IM);
End;
Count:=count-1;
If(flag0&plate[0]==fruit) then
{x:=plate[0];flag0:=false;}
Else{x:=plate[1];flag1:=false;}
Signal(SP,IM);
Release(IM);
End;
Begin
Count:=0;flag0:=false;flag1:=false; SP:=0;ss:=0;sd:=0;
Plate[0]:plate[1]:=null;
End;
Main()
{cobegin
Process father
Begin
While(1)
{准备好苹果；
Call FMSD.put(apple);
……
}
End;
Process mother
Begin
While(1)
{
准备好桔子；
Call FMSD.put(orange);
……
}
End;
Process son
Begin
While(1)
{call FMSD.get(orange,x);
吃取到的桔子；
……
}
End;
Process daughter
Begin
While(1)
{
Call FMSD.get(apple,x);
吃取到的苹果；
……
}
End;
}
Coend

```



## 43

现有三个生产者P1、P2、P3，他们都要生产橘子汁，每个生产者都已分别购得两种不同的原料，待购齐第三种原料后就可配制成橘子汁装瓶出售。有一供应商能源源不断地供应糖、水、橘子精，但每次只拿出一种原料放入容器中供应给生产者。当容器中有原料时，需要这种原料的生产者可以取走，当容器空时供应商又可放入一种原料。假定：生产者P1已购得糖和水；生产者P2已购得水和橘子精；生产者P3已购得糖和橘子精。试用（1）管程、（2）信号量与PV操作，写出供应商和三个生产者之间能正确同步的程序。

```
答：1 ）管程．
TYPE makedrink = monitor 
VAR S , S1 , S2 , S3 : condition ; 
container:item ; 
DEFINE give , produce1 , produce2 , produce3 ; 
USE check , wait , signal , re lease ; 
procedure give 
begin 
Check ( IM ) ; 
take raw material ; 
ifcontainer≠null then wait ( S , IM ) ; 
else container : = rawn materiai ; 
if （container）=桔子精then singal ( s1 , IM ) ; 
   eise if ( container)=糖 then signal(S2 ，IM）; 
       else signal ( S3 , IM ) ; 
release ( IM ) ; 
end 
procrdure produce1
begin 
check ( IM ) ; 
if ( c ontainer ）≠桔子精 then wait ( s1 , IM ) ; 
else { take the 桔子精 from container ；做桔子水；} 
signal ( S ，IM）; 
re1ease ( IM ) ; 
end 
procrdure produce2 
begin 
check(IM);
IF(CONTAINER)≠糖 then wait(S2,IM);
Else{take the 糖 from container;做橘子水；}
Signal(S,IM);
Release(IM);
End
Procrdure produce3
 Begin
   Check(IM);
   If(container)≠水 then wait(S3,IM);
   Else{take the 水 from container;做橘子水;}
   Signal(S,IM);
   Release(IM);
End
Begin
Container{糖，水，橘子精};
End
Cobegin
{
  Process 供应商
   Begin 
       Repeat
           …
       Call makedrink.give();
          …
       Until false;
End
Process P1
 Begin repeat
…
Call makedrink.produce1();
…
Until false;
End
Process P2
Begin 
 Repeat 
 …
 Call makedrink.produce2();
 …
Until false;
End
Process P3
Begin
 Repeat
  …
  Call makedrink,produce3();
  …
  Until false;
End
}
Coend.
2)信号量与P、V操作
Var S,S1,S2,S3:=semaphore;
S:=1,S1:=S2:=S3:=0;
Container{糖，水，橘子精};
Cobegin
{ process 供应商
  Begin 
   Repeat
   P(s);
   Take raw material into container;
   If (container)=橘子精 then V(S1);
   Else if (container)=糖then V(s2);
   Else V(s3);
   Until false;
End
Process P1
 Begin 
Repeat
P(S1);
Take the 橘子精 from container;
V(s);
做橘子水；
Until false;
End
Process P2
Begin 
Repeat
P(s2);
Take the 糖from container;
V(s);
做橘子水;
Until false;
End
process P3 
begin 
repeat 
P ( S3 ) ; 
take the 水 from container;
V ( S ) ; 
做桔子水；
untile false ; 
end 
} 
coend . 

```



# 第四章

## 15

在一分页存储管理系统中，逻辑地址长度为16位，页面大小为4096B，现有逻辑地址2F6AH，且第0、1、2页依次存放在第10、12、14号物理块中，试问相应的物理地址是多少？

> 页面大小为4096字节，4096等于2的12次方,故页内地址为12位,又逻辑地址长度为16位,故高4位表示页号。逻辑地址2F6AH的高四位为的值为2，则逻辑地址2F6AH在第2页。根据页表可知，页号第2页存于第14块中。14的十六进制为EH，与低12位F6AH拼接得物理地址为EF6AH

![图片1](image/4-15-logicalAddressToPhysicalAddress.png)

## 20

在一个分页虚拟存储系统中，用户编程空间为32个页，页长1KB，内存空间为16KB。如果应用程序有10页长，若已知虚页0、1、2、3，已分得页框4、7、8、10，试把虚地址0AC5H和1AC5H转换成对应的物理地址。

> 虚地址 0AC5H 对应的物理地址为：22C5H
> 虚地址 1AC5H 会发现页表中尚未有分配的页框而发生缺页中断，由系统另行分配页框
>
> --------------------------------------------------------------------------------------------------------
>
> 页式存储管理的逻辑地址分为两部分:页号和页内地址
> 由已知条件"用户编程空间共32个页面"，可知页号部分占5位
> 由"每页为1KB"，1K=2<sup>10</sup>，可知内页地址占10位
> 逻辑地址0AC5H所对应的二进制表示形式是:000 10<u>10 1100 0101</u> 
> 根据上面的分析，下划线部分为页内地址，编码“000 10”为页号，表示该逻辑地址对应的页号为2
>查页表，得到物理块号是8，即物理块地址为: 01000 
> 拼接块内地址<u>010 1100 0101</u>得**010 00<u>10 1100 0101</u>** ，即 22C5H
> 
>逻辑地址1AC5H所对应的二进制表示形式是:001 10<u>10 1100 0101</u> 
> 根据上面的分析，下划线部分为页内地址，编码“001 10”为页号，表示该逻辑地址对应的页号为6
> 查页表，查不到，发生缺页中断，由系统另行分配页框

## 25

一个有快表的页式虚拟存储系统，设内存访问周期为1us，主外存传送一个页面的平均时间为5ms。如果快表的命中率为75%，缺页中断率为10%，忽略快表访问时间，试求内存的有效存取时间。

> 快表命中率为75%，缺页中断率为10%，所以，内存命中率=1-75%-10%=15%
> 在快表：75%×1us(内存访问周期)×75%
> 在内存：15%×[1us(内存访问周期) + 1us(内存调入块表)]
> 在外存：10%×[1us(内存访问周期) + 1us(内存调入块表)+5000us(主外存传送一个页面)]
> 故内存的有效存取时间=1×75%+2×15%+(5000+2)×10%=501.25微秒。

## 26

假设某虚存的用户空间为1024KB，页面大小为4KB，内存空间为512KB。已知用户的10、11、12、13号虚页分得内存页框号为62、78、25、36，求出虚地址 0BEBCH（十六进制）的实地址（十六进制）。

> 虚地址 0BEBC(16 进制 )的二进制形式为：0000 1011 1110 1011 1100。
> 由于页面大小为4KB ，故其中后12 位是内页地址：**0000 1011 <u>1110 1011 1100</u>**
> 由此可知虚地址的页号为：11
> 查页表分得内存对应页框号为：78
> 已知内存空间为512KB ，页面大小为4KB,故内存共有 512KB/4KB=128 个页框， 78 是合法物理块
> 把78 化为 16 进制是 4E，虚地址 0BEBC(16 进制 )的实地址 (16 进制 )是： 4EEBC 

## 29

考虑下列段表：

| 段号 | 起始地址 | 段长  |
| ---- | -------- | ----- |
| 0    | 2 0 0    | 5 0 0 |
| 1    | 8 9 0    | 3 0   |
| 2    | 1 2 0    | 1 0 0 |
| 3    | 1 2 5 0  | 6 0 0 |
| 4    | 1 8 0 0  | 8 8   |

对于下面的逻辑地址求物理地址，如发生越界请指明。

（1）<0，480>；（2）<1，25>；（3）<1，14>：(4)<2，200>：(5)<3，500>：(6)<4，100>。

> 1. 680
> 1. 915
> 2. 904
> 3. 越界
> 4. 1750
> 5. 越界

## 30

请页式虚存管理系统中，进程访问地址的序列为：10，11，104，170，73，305，180，240，244，445，467，366。试问：（1）如果页面大小为100B，给出页面访问序列。（3）若进程分得三个页框，采用FIFO和LRU替换算法，求缺页中断率。

> (1) 
>
> ​    页面访问序列为
> ​     1，1， 2，2，1，4，2， 3，3，5，5，4。
>
> ```
> 已知页面大小为100，则可分成第1页：0-100，第2页：100-200... ...第5页：400-500
> 根据已知进程访问序列，可知10在第1页内，11在第1页内，以此类推得出页面访问序列：
> 1,1,2,2,1,4,2,3,3,5,5,4 
> ```
>
> (2)
> ​    FIFO 为 5 次，缺页中断率为5/12=41.6%。
> ​    LRU 为 6 次，缺页中断率为6/12=50%。
> ​    LRU 反比 FIFO 缺页中断率高。
>
> [3.2_3_页面置换算法](https://www.bilibili.com/video/BV1YE411D7nH?p=46)

## 31

 31、设程序大小为460个字，考虑如下访问序列：55，20，108，180，79，310，170，255，246，433，488，369。试问：（1）设页面大小为100个字，给出访问序列页面走向。（2）假设程序可用内存为200个字，采用FIFO、LRU和OPT淘汰算法，求出缺页中断率。

> (1) 0 0 1 1 0 3 1 2 2 4 4 3
>
> (2)
>
> | 算法      | 页面走向                | 缺页中断率 |
> | --------- | ----------------------- | ---------- |
> | FIFO 算法 | 0 0 1 1 0 3 1 2 2 4 4 3 | 6/12=50%   |
> | LRU 算法  | 0 0 1 1 0 3 1 2 2 4 4 3 | 7/12=58.3% |
> | OPT 算法  | 0 0 1 1 0 3 1 2 2 4 4 3 | 5/12=41.7% |

# 第六章

## 14

有一个磁盘组共有10 个盘面，每个盘面有100 个磁道，每个磁道有16 个扇区。若以扇区为分配单位，现问：用位示图管理磁盘空间，则位示图占用多少空间？ 若空白文件目录的每个目录项占5 个字节，则什么时候空白文件目录大于位示图？

-------------------------------------------------------------------------------------------------

```
已知磁盘盘组共有10个盘面，每个盘面上有100个磁道，每个磁道有16个扇区，则一共有10×100×16=16000个扇区。试题以扇区为分配单位，即一共有16000个分配单位。因此，位图所占的空间为16000/8=2000字节

若采用空白文件管理磁盘空间，且空白文件目录的每个表项占用5个字节，2000B/5B=400(个)，因此，则当空白文件数目大于400个时，空白文件目录占用的字节数大于位图占用的字节数
```

## 15

磁盘共有100个柱面，每个柱面有8个磁头，每个盘面分4个扇区。若逻辑记录与扇区等长，柱面、磁道、扇区均从0起编号。现用16位的200个字(0-199)来组成位示图来管理盘空间。现问：
(1)位示图第15个字的第7位为0而准备分配给某一记录，该块的柱面号、磁道号、扇区号是多少?
(2)现回收第56柱面第6磁道第3扇区，这时位示图的第几个字的第几位应清0?

```
(1)
位示图第15个字的第7位对应的块号=15×16(字长)+7=247，而块号247对应的：
  柱面号=247/(8×4)=7(从0编号，向下取整)
  磁头号=(247%(8×4))/4=5
  扇区号=(247%(8×4))%4=3

(2)
块号=柱面号×柱面扇区数+磁道号×盘扇区+盘扇区=56×(8×4)+6×4+3=1819
字号=1819/16=113
位号=1819%16=11
所以，回收第56柱面第6磁道第3扇区时，位示图的第113字的第11位应清0
```

## 16

如果一个索引节点为128B ，指针长4B ，状态信息占用68B ，而每块大小为8KB 。问索引节点中有多大空间留给磁盘块指针？使用直接、一次间接、二次间接和三次间接指针分别可表示多大的文件？ 

-----------------------------------------------------------------------------------------------------


```
由于索引节点为128B,而状态信息占用68B,故索引节点中用于磁盘指针的空间大小为：128B-68B=60B。
每块索引节点大小为8KB，因此直接指针指向的磁盘块大小是8KB。一次间接、二次间接和三次间接指针占用三个指针项，因而直接指针项数为：(60B/4B)-3=12(个)，则指向的总磁盘大小是：12*8KB=96KB

每块索引节点大小为8KB，因此一次间接指针指向的直接指针磁盘块大小是8KB。一次间接指针可以提供的直接指针有：8KB/4B=2K(个)，则一次间接指针指向的总磁盘大小是：2K*8KB=16MB

每块索引节点大小为8KB，因此二次间接指针指向的一次间接指针磁盘块大小是8KB。二次间接指针可以提供的一次间接指针有：8KB/4B=2K(个)，则二次间接指针指向的总磁盘大小是：2K*16MB=32GB

每块索引节点大小为8KB，因此三次间接指针指向的二次间接指针磁盘块大小是8KB。三次间接指针可以提供的二次间接指针有：8KB/4B=2K(个)，则指向的总磁盘大小是：2K*32GB=64TB
```

## 17

在一个操作系统中，inode 节点中分别含有12 个直接地址索引和一、二、三级间接地址索引。若设每个盘块有 512B 大小，每个盘块中可存放128 个盘块地址，则(1) 一个 1MB的文件占用多少间接盘块？(2) 一个 25MB的文件占用多少间接盘块？

```
inode节点中分别含有12个直接地址,每个盘块有512B大小,则直接块容量=12×512B=6KB
一次间接容量=128×512B=64KB
二次间接容量=128×128×512B=8MB
三次间接容量=128×128×128×512B=1GB

占用12个直接盘块后剩余：1MB-6KB=1018KB
再占用一级间接地址索引指向的128个一级间接盘块后剩余：1MB-6KB-64KB=954KB
剩下的部分占用了二级间接盘块：(1MB-6KB-64KB)/512B=1908(块)

占用12个直接盘块后剩余：25M-6KB
再占用一级间接地址索引指向的128个一级间接盘块后剩余：25M-6KB-64KB
再占用二级间接地址索引指向的128*128个二级间接盘块后剩余：25M-6KB-64KB-8M
剩下的部分占用了三级间接盘块：(25MB-6KB-64KB-8MB)/512B=34676(块)
```

